> 인터럽트
> 

컨트롤러가 cpu에게 처리가 끝났다고 알려준다. cpu는 다른일을 하고 있다가 처리가 끝나면 인터럽트가 들어왔는지 확인하고, 들어왔으면 cpu는 운영체제한테 넘어가서 운영체제는 그 이유를 보고 cpu스케쥴링 단계에서 다음번에 수행이 될 수 있도록 해준다. 

사람이 키보드를 두드리면 키보드 컨트롤러가 cpu에게 인터럽트를 걸어서, cpu가 운영체제에 넘어가고 입력으로 들어온 내용을 메모리로 전달해준다.

> CPU 스케쥴링
> 
- **FCFS(First-Come Firts Served)**
    
    먼저 들어온 프로세스를 먼저 처리하는 순서를 가진다. 효율성 측면에서 좋지않다.
    
    먼저 들어온 프로세스 처리 시간이 굉장히 긴 것이라면 나머지 뒤에 들어온 것들은 처리 되지 못한 상태로 계속 큐에 남아 있게 된다. 
    
- **SJF(Shortest Job First)**
    
    CPU 사용시간이 가장 짧은 프로세스를 제일 먼저 스케줄한다.
    
    스케쥴링 방법중에서는 가장 빠른 처리시간을 갖는다. 그러나, starvation(무한정 대기)가 발생할 수 있기에, 형평성에 어긋나게 된다. 긴 프로그램은 cpu를 영원히 못쓸 수 있는 상황이 오게 된다.
    
- **Round Robin(RR)**
    
    각 프로세스에게 동일한 시간의 CPU할당시간을 제공한다.
    
    할당시간이 끝나면 인터럽트가 발생하여 프로세스는 CPU를 빼앗기고, CPU 큐의 제일 뒤에 줄을 섬
    
    - n개의 프로세스가 cpu 큐에 대기하고 있는 경우
        
        → 어떤 프로세스도 (n-1) 할당 시간 이상 기다리지 않음
            (짧은 프로세스는 할당시간보다 일찍 끝나면 그대로 끝내버리기 때문에 효율성도 크게 가져갈 수 있음)
        
        → 대기시간이 프로세스의 cpu 사용시간에 비례한다.
        

> 메모리 스케쥴링
> 

컴퓨터를 사용하는 동안에는 운영체제가 메모리에 할당 되어있고, 디스크에 있는 실행파일을 실행하면 메모리에 프로세스로 올라오게 된다. 이 과정 중에 프로그램이 바로 물리적인 메모리에 올라오는 것은 아니고 가상메모리 공간에 만들어 진다. 

실행파일에서 가상메모리를 만들어 놓고 물리메모리에는 당장 필요한 부분만 쪼개서 물리메모리에 올리게 된다.


> 시스템콜
> 

응용프로그램은 OS가 제공하는 인터페이스를 통해서만 자원을 사용할 수 있다. OS가 제공하는 이러한 인터페이스를 시스템콜(System Call) 이라고 한다.

- 종류
1. 프로세스 제어(Process Control)
    - fork()
    - exit()
    - wait()
2. 파일 조작(File Manipulation)
    - open()
    - read()
    - write()
    - close()
3. 장지 조작(Device Manipulation)
    - ioctl()
    - read()
    - write()
4. 정보 유지(Information Maintenance)
    - getpid()
    - alarm()
    - sleep()
5. 통신(Commnication)
    - pipe()
    - shm_open()
    - mmap()
6. 보호(Protection)
    - chmod()
    - umask()
    - chown()
